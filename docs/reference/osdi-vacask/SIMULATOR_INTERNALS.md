# VACASK Simulator Internals for Ring Benchmark

This document provides detailed information about VACASK's internal algorithms for comparison with other simulators.

## 1. Device Model Evaluation (OpenVAF Output, Cached Values)

### OSDI Descriptor Structure

OpenVAF compiles Verilog-A models to shared libraries that implement the OSDI 0.4 API. The `OsdiDescriptor` structure defines the interface:

```c
typedef struct OsdiDescriptor {
    // Device identification
    char *name;
    uint32_t num_nodes;
    uint32_t num_terminals;
    OsdiNode *nodes;

    // Jacobian structure (pre-computed sparsity pattern)
    uint32_t num_jacobian_entries;
    OsdiJacobianEntry *jacobian_entries;
    uint32_t num_resistive_jacobian_entries;
    uint32_t num_reactive_jacobian_entries;

    // Node collapsing info
    uint32_t num_collapsible;
    OsdiNodePair *collapsible;
    uint32_t collapsed_offset;

    // Parameter info
    uint32_t num_params;
    uint32_t num_instance_params;
    uint32_t num_opvars;
    OsdiParamOpvar *param_opvar;

    // Memory layout offsets
    uint32_t node_mapping_offset;
    uint32_t jacobian_ptr_resist_offset;
    uint32_t state_idx_off;
    uint32_t bound_step_offset;
    uint32_t instance_size;
    uint32_t model_size;

    // API functions (generated by OpenVAF)
    void *(*access)(void *inst, void *model, uint32_t id, uint32_t flags);
    void (*setup_model)(void *handle, void *model, OsdiSimParas *sim_params, OsdiInitInfo *res);
    void (*setup_instance)(void *handle, void *inst, void *model, double temperature,
                           uint32_t num_terminals, OsdiSimParas *sim_params, OsdiInitInfo *res);
    uint32_t (*eval)(void *handle, void *inst, void *model, OsdiSimInfo *info);
    void (*load_noise)(void *inst, void *model, double freq, double *noise_dens);
    void (*load_residual_resist)(void *inst, void *model, double *dst);
    void (*load_residual_react)(void *inst, void *model, double *dst);
    void (*load_limit_rhs_resist)(void *inst, void *model, double *dst);
    void (*load_limit_rhs_react)(void *inst, void *model, double *dst);
    void (*load_jacobian_resist)(void *inst, void *model);
    void (*load_jacobian_react)(void *inst, void *model, double alpha);
    void (*load_jacobian_tran)(void *inst, void *model, double alpha);
    // ... additional functions
} OsdiDescriptor;
```

### Cached Values in Instance Core

Each OSDI instance maintains a memory block (`core_`) containing:

| Offset | Data | Purpose |
|--------|------|---------|
| `node_mapping_offset` | Node mapping array | Maps internal nodes to system unknowns |
| `collapsed_offset` | Collapsed nodes pattern | Bitmap of collapsed internal nodes |
| `jacobian_ptr_resist_offset` | Jacobian pointers (resist) | Direct pointers to sparse matrix entries |
| `jacobian_ptr_react_offset` | Jacobian pointers (react) | Reactive Jacobian pointers |
| `state_idx_off` | State index table | Maps states to global state vector |
| `nodes[i].resist_residual_off` | Node residuals (resist) | I(V) contributions per node |
| `nodes[i].react_residual_off` | Node residuals (react) | Q(V) contributions per node |
| `nodes[i].resist_limit_rhs_off` | Limiting RHS (resist) | Linearized limiting correction |
| `nodes[i].react_limit_rhs_off` | Limiting RHS (react) | Reactive limiting correction |
| `(model-specific)` | Parameters & internal vars | Model and instance parameters |

### Evaluation Flow (evalCore)

The `eval()` function generated by OpenVAF performs:

1. **Read terminal voltages** from solution vector via node mapping
2. **Evaluate model equations** (branch currents, charges, noise)
3. **Compute Jacobian derivatives** (∂I/∂V, ∂Q/∂V)
4. **Apply limiting functions** if enabled (pnjlim, fetlim, etc.)
5. **Store results** in instance core memory

### Evaluation Flags

```c
#define CALC_RESIST_RESIDUAL     1    // Compute I(V)
#define CALC_REACT_RESIDUAL      2    // Compute Q(V)
#define CALC_RESIST_JACOBIAN     4    // Compute dI/dV
#define CALC_REACT_JACOBIAN      8    // Compute dQ/dV
#define CALC_NOISE              16    // Compute noise sources
#define CALC_OP                 32    // Operating point analysis
#define CALC_RESIST_LIM_RHS     64    // Compute limiting RHS (resist)
#define CALC_REACT_LIM_RHS     128    // Compute limiting RHS (react)
#define ENABLE_LIM             256    // Enable limiting
#define INIT_LIM               512    // Initialize limiting state
#define ANALYSIS_DC           2048    // DC analysis flag
#define ANALYSIS_TRAN         8192    // Transient analysis flag
```

### Return Flags

```c
#define EVAL_RET_FLAG_LIM     1   // Limiting was applied
#define EVAL_RET_FLAG_FATAL   2   // Fatal error, abort
#define EVAL_RET_FLAG_FINISH  4   // $finish called
#define EVAL_RET_FLAG_STOP    8   // $stop called
```

---

## 2. Charge Integration (dQ/dt Operator)

### General Formulation

Circuit equations in transient:
```
f(x(t)) + d/dt q(x(t)) = 0

where:
  x(t) = solution (unknowns)
  f(x) = resistive residual (currents)
  q(x) = reactive residual (charges)
```

### Integration Methods

VACASK supports two families of implicit integration methods:

#### Adams-Moulton (AM)

```
x_{k+1} = a_0 * x_k + h_k * (b_{-1} * x'_{k+1} + b_0 * x'_k + b_1 * x'_{k-1} + ...)

Order 1: Backward Euler
  a_0 = 1, b_{-1} = 1

Order 2: Trapezoidal (with xmu parameter)
  a_0 = 1
  b_{-1} = 1 - xmu  (default xmu=0.5 gives pure trapezoidal)
  b_0 = xmu

  Special cases:
    xmu = 0.5: Pure trapezoidal (b_{-1} = b_0 = 0.5)
    xmu = 0.0: Backward Euler (b_{-1} = 1, b_0 = 0)
```

#### BDF (Backward Differentiation Formula, aka Gear)

```
sum_{i=0}^{order-1} a_i * x_{k-i} = h_k * b_{-1} * x'_{k+1}

Order 1: Backward Euler (same as AM1)
  a_0 = 1, b_{-1} = 1

Order 2: Gear-2
  a_0 = 18/11, a_1 = -9/11, a_2 = 2/11
  b_{-1} = 6/11
```

### Differentiate Function

To compute ẋ(t_{k+1}) from x(t_{k+1}):

```cpp
double differentiate(double futureValue, GlobalStorageIndex state) {
    // leading_ = 1 / (h_k * b_{-1})
    double deriv = leading_ * futureValue;

    // Past values contribution
    for (int i = 0; i < aScaled_.size(); i++) {
        // aScaled_[i] = a_i / (h_k * b_{-1})
        deriv -= aScaled_[i] * history[i][state];
    }

    // Past derivatives contribution (AM methods only)
    for (int i = 0; i < bScaled_.size(); i++) {
        // bScaled_[i] = b_i / b_{-1}
        deriv -= bScaled_[i] * history[i][state + 1];  // state+1 holds derivative
    }

    return deriv;
}
```

### Transient Jacobian Contribution

The reactive contribution to the system Jacobian:

```
di/dx|_{k+1} = (1 / (h_k * b_{-1})) * dq/dx|_{k+1}
                 ↑                      ↑
              alpha                reactive Jacobian
```

This is loaded via:
```cpp
descriptor->load_jacobian_tran(instance, model, alpha);
// Adds: dI/dV + alpha * dQ/dV  where alpha = 1/(h_k * b_{-1})
```

### State Vector Layout

For each node with reactive residual:
```
states[2*i]   = q(t_k)      // Charge at current timepoint
states[2*i+1] = q'(t_k)     // dq/dt at current timepoint (computed current)
```

### Integration Coefficient Computation

Coefficients are recomputed at each timestep to handle variable step sizes:

```cpp
bool IntegratorCoeffs::compute(CircularBuffer<double>& pastSteps, double newStep) {
    // Normalize past timepoints by new step
    normalizedTimePoint[0] = 0.0;  // t_k
    for (int i = 0; i < pastSteps.valueCount(); i++) {
        normalizedTimePoint[i+1] = normalizedTimePoint[i] - pastSteps.at(i);
    }
    for (int i = 1; i < normalizedTimePoint.size(); i++) {
        normalizedTimePoint[i] /= newStep;
    }

    // Build and solve system of equations for coefficients
    // ...
}
```

---

## 3. Newton-Raphson Residual/Convergence Handling

### NR Algorithm Overview

```cpp
// Pseudocode for NR loop
run(continuePrevious) {
    initialize();
    if (!continuePrevious) {
        zero(solution);
    }
    do {
        zero(Jacobian, residual);
        preIteration();
        buildSystem();          // Evaluate devices, load Jacobian and residual
        loadForces();           // Apply nodesets/ICs
        [ok, limiting] = checkResidual();
        factor_and_solve();     // KLU sparse solver
        postSolve();
        checkDelta();           // Only if iteration > 1
        checkConvergence();
        if (converged) break;
        update_solution();
        rotate_solutions();
        postIteration();
    } while (iteration < itlim);
}
```

### NR Settings

```cpp
struct NRSettings {
    int debug {0};           // Debug verbosity level
    Int itlim {100};         // Iteration limit (first point)
    Int itlimCont {50};      // Iteration limit (continuation)
    Int convIter {1};        // Required consecutive converged iterations
    bool residualCheck {true};
    Real dampingFactor {0.8};
    bool matrixCheck {};
    bool rhsCheck {};
    bool solutionCheck {};
    Real forceFactor {1e5};  // Force scaling factor
};
```

### Convergence Criteria

#### Residual Check (checkResidual)

For each unknown i (excluding ground):

```cpp
// Compute tolerance reference
double tolref = |maxResidualContribution[i]|;

// Apply historic/global reference if configured
if (historicResRef) {
    if (globalResRef) {
        tolref = max(tolref, globalMaxResidualContribution[nature_index]);
    } else {
        tolref = max(tolref, historicMaxResidualContribution[i]);
    }
} else if (globalResRef) {
    tolref = max(tolref, pointMaxResidualContribution[nature_index]);
}

// Compute tolerance
double tol = max(|tolref * reltol|, abstol[i]);

// Check if residual is within tolerance
if (|residual[i]| > tol) {
    residualOk = false;
}
```

Where:
- `reltol` = relative tolerance (default 1e-3)
- `abstol[i]` = absolute tolerance based on nature (voltage: vntol, current: abstol)

#### Delta Check (checkDelta)

For each unknown i:

```cpp
// Compute tolerance reference (from previous solution)
double tolref = |x_prev[i]|;

// Apply historic/global reference if configured
if (historicSolRef) {
    if (globalSolRef) {
        tolref = max(tolref, globalMaxSolution[nature_index]);
    } else {
        tolref = max(tolref, historicMaxSolution[i]);
    }
} else if (globalSolRef) {
    tolref = max(tolref, pointMaxSolution[nature_index]);
}

// Compute tolerance
double tol = max(|tolref * reltol|, abstol[i]);

// Check if solution change is within tolerance
if (|delta[i]| > tol) {
    deltaOk = false;
}
```

### Convergence with Limiting

When limiting is applied, convergence is prevented:

```cpp
[ok, limitingApplied] = buildSystem();
// If limitingApplied is true, do not allow convergence this iteration
```

### SPICE Formulation with Limiting

```
Gl_i * (x_i - x_{i+1}) = f(xl_i) - Gl_i * (xl_i - x_i)
                         ↑         ↑
                      residual    RHS linearized residual
```

Where:
- `xl_i` = limited unknowns (after applying pnjlim, fetlim, etc.)
- `Gl_i` = Jacobian evaluated at limited point
- `f(xl_i)` = residual at limited point

---

## 4. Time-Stepping Algorithms

### Method Selection

```cpp
// Available methods (tran_method option)
"euler"  → AdamsMoulton order 1
"trap"   → AdamsMoulton order 2 (default xmu=0.5)
"am"     → AdamsMoulton order 1..tran_maxord
"bdf"    → BDF order 1..tran_maxord
"gear"   → BDF order 1..tran_maxord (alias)
"bdf2"   → BDF order 2 fixed
"gear2"  → BDF order 2 fixed (alias)
```

### Trapezoidal Algorithm (default)

Integration formula:
```
x_{k+1} = x_k + h_k * ((1-xmu) * x'_{k+1} + xmu * x'_k)

For xmu = 0.5 (pure trapezoidal):
x_{k+1} = x_k + (h_k/2) * (x'_{k+1} + x'_k)
```

Differentiate:
```
x'_{k+1} = (2/h_k) * (x_{k+1} - x_k) - x'_k
         = (2/h_k) * x_{k+1} - (2/h_k) * x_k - x'_k
```

Leading coefficient: `alpha = 2/h_k`

Error coefficient: `C = (1/24) * 3! = 1/4` (multiplied by (order+1)!)

### BDF-2 (Gear-2) Algorithm

Integration formula:
```
(18/11)*x_k - (9/11)*x_{k-1} + (2/11)*x_{k-2} = (6/11) * h_k * x'_{k+1}
```

Differentiate:
```
x'_{k+1} = (11/(6*h_k)) * ((18/11)*x_k - (9/11)*x_{k-1} + (2/11)*x_{k-2})
         = (3/h_k)*x_k - (3/(2*h_k))*x_{k-1} + (1/(3*h_k))*x_{k-2}
```

Leading coefficient: `alpha = 11/(6*h_k) ≈ 1.833/h_k`

Error coefficient: `C = (3/22) * 3! = 9/11`

### Timestep Control

Initial timestep `h0` is limited by:
1. User-specified `step` parameter
2. `maxstep` if specified
3. `tran_ffmax/(2*maxFreq)` if fast frequency limit is set
4. `tran_fbr * (nextBreakpoint - lastBreakpoint)` near breakpoints
5. `boundStep` from device evaluation
6. Scaled by `tran_fs` factor

### LTE (Local Truncation Error) Based Control

```cpp
// Predictor uses polynomial extrapolation
predictorCoeffs.setMethod(PolynomialExtrapolation, order);

// Predict x_{k+1} from history
predict(predictedSolution);

// After NR convergence, estimate LTE
for (int i = 1; i <= n; i++) {
    double lte = |solution[i] - predictedSolution[i]| / errorCoeff;
    scaledLte[i] = lte / tol[i];
}

// Compute optimal step
double maxScaledLte = max(scaledLte);
double q = pow(1.0 / maxScaledLte, 1.0 / (order + 1));
double hNew = q * hk;

// Clamp to reasonable range
hNew = clamp(hNew, hk * tran_fmin, hk * tran_fmax);
```

### Breakpoint Handling

Breakpoints occur at:
- PWL source transitions
- User-specified times
- `tstop` and `tstart`

```cpp
// Next solve time respects breakpoints
double nextBreakpoint = breakPoints.at(0);
if (tk + hk >= nextBreakpoint) {
    tSolve = nextBreakpoint;  // Land exactly on breakpoint
    hk = tSolve - tk;
}
```

### State Machine for Timestep Loop

```
1. Initial point at t=0 (via OP analysis or UIC)
2. Rotate states: current(0) → past(1)
3. Initialize: order=1, hk=h0

LOOP:
4. Compute coefficients for current order and step
5. Predict solution at t_{k+1}
6. Set up NR: solution[0] = predicted
7. Run NR solver at t_{k+1}
8. If NR failed:
   - Reduce timestep
   - If too small, abort
   - Retry from step 4
9. Check LTE
10. If LTE too large:
    - Reduce timestep
    - Retry from step 4
11. Accept point
12. Update maxima
13. Write output if t >= tstart
14. If t >= tstop: DONE
15. Compute next timestep
16. Rotate: current → past
17. Update order if history allows
18. GOTO LOOP
```

---

## 5. Numerical Robustness and Large Capacitance Handling

VACASK does not have explicit "large capacitance" detection or limiting. Instead, it relies on several general mechanisms that naturally handle extreme component values.

### Device-Level Timestep Bounding (`$bound_step`)

Verilog-A models can call `$bound_step(value)` to limit the simulator timestep. This is the primary mechanism for devices to communicate timestep constraints:

```cpp
// In EvalSetup (elsetup.h)
double boundStep {};  // Initialized to -1, set by devices

void setBoundStep(double bound) {
    if (bound < boundStep) boundStep = bound;
}

// Applied in coretran.cpp:1294
if (boundStep > 0) {
    if (debug > 1 && boundStep < hkNew) {
        Simulator::dbg() << "Instance(s) limit timestep to dt=" << boundStep << ".\n";
    }
    hkNew = std::min(hkNew, boundStep);
}
```

If a device model detects conditions requiring small timesteps (e.g., large dV/dt across a large capacitor), it can enforce this constraint.

### LTE-Based Automatic Timestep Reduction

Large capacitances naturally produce larger local truncation errors when voltages change rapidly:

```
LTE ∝ C * d²V/dt² * h^(order+1)
```

For trapezoidal integration (order 2):
- Large C with changing V → large LTE
- LTE/tolerance > 1 triggers timestep rejection
- New step: `h_new = h * (tolerance/LTE)^(1/3)`

This provides automatic protection without explicit capacitance checks.

### Matrix Conditioning and Numerical Checks

VACASK provides optional checks for numerical problems:

| Option | Default | Description |
|--------|---------|-------------|
| `matrixcheck` | 0 | Check Jacobian entries for inf/NaN |
| `rhscheck` | 1 | Check RHS vector for inf/NaN |
| `solutioncheck` | 1 | Check solution vector for inf/NaN |
| `rcondcheck` | 0 | Check reciprocal condition number (if > 0) |

#### Matrix Check

```cpp
// In NR solver iteration
if (settings.matrixCheck && !jacobian.isFinite(true, true)) {
    // Iteration fails, timestep will be reduced
    lastError = Error::MatrixError;
    return false;
}
```

#### Condition Number Check (AC/Noise analyses)

```cpp
// In coreac.cpp, corenoise.cpp, coreacxf.cpp
if (options.rcondcheck > 0) {
    double rcond;
    if (!acMatrix.rcond(rcond)) {
        setError(AcError::MatrixError);
        break;
    }
    if (rcond < options.rcondcheck) {
        Simulator::dbg() << "Matrix is close to singular.\n";
        setError(AcError::MatrixError);
        break;
    }
}
```

### Singular Matrix Detection

KLU (the sparse solver) detects zero pivots during factorization:

```cpp
// klumatrix.cpp:738
if (!numeric || isSingular || (nr >= 0 && nr != AN)) {
    lastError = Error::Factorization;
    errorIndex = singularColumn();
    // Error message: "Factorization failed, zero pivot @ node 'xxx'"
}
```

A large capacitance can contribute to singularity if:
- The `alpha = 1/(h*b_{-1})` term becomes very small (large timestep)
- Combined with small conductances elsewhere in the circuit

### Jacobian Contribution from Capacitance

During transient analysis, a capacitor C between nodes i and j contributes:

```
Jacobian[i,i] += alpha * C
Jacobian[i,j] -= alpha * C
Jacobian[j,i] -= alpha * C
Jacobian[j,j] += alpha * C

where alpha = 1/(h * b_{-1})
```

For trapezoidal: `alpha = 2/h`

**Potential issues with large C:**
- If `h` is large, `alpha*C` may be comparable to other conductances → OK
- If `h` is small (forced by LTE), `alpha*C` becomes very large → dominates matrix
- Very large `alpha*C` can cause conditioning issues if other elements are small

### What VACASK Does NOT Do

Unlike some SPICE variants, VACASK does not:
- Automatically insert `gmin` shunts across capacitors
- Warn about "unrealistic" capacitance values
- Scale or limit capacitance values
- Have special handling for floating capacitors

### Debugging Large Capacitance Issues

To diagnose problems with large capacitances:

```
control
  // Enable all numerical checks
  options matrixcheck=1
  options rhscheck=1
  options solutioncheck=1
  options rcondcheck=1e-15

  // Enable detailed debug output
  options tran_debug=2
  options nr_debug=1

  analysis tran step=1n stop=100n
endc
```

Signs of large capacitance problems:
1. **Very small timesteps** - LTE control forcing tiny steps
2. **"Matrix entry is not finite"** - overflow in Jacobian
3. **"Matrix is close to singular"** - conditioning issues
4. **"Factorization failed, zero pivot"** - numerical singularity
5. **Many NR iterations** - slow convergence due to stiff system

### Recommendations for Large Capacitances

1. **Use `maxstep`** to prevent excessively large timesteps:
   ```
   analysis tran step=1n stop=1u maxstep=10n
   ```

2. **Consider BDF-2** for stiff circuits (large C with small R):
   ```
   options tran_method="gear2"
   ```
   BDF-2 is A-stable and better suited for stiff systems.

3. **Enable matrix checks** during development:
   ```
   options matrixcheck=1 rcondcheck=1e-14
   ```

4. **Check device models** - ensure `$bound_step` is called appropriately for large reactive elements.

---

## Summary: Key Numerical Parameters

| Parameter | Default | Description |
|-----------|---------|-------------|
| `reltol` | 1e-3 | Relative tolerance |
| `vntol` | 1e-6 | Absolute voltage tolerance |
| `abstol` | 1e-12 | Absolute current tolerance |
| `tran_method` | "trap" | Integration method |
| `tran_maxord` | 2 | Maximum order |
| `tran_xmu` | 0.5 | Trapezoidal damping (0=Euler, 0.5=pure trap) |
| `nr_itl` | 100 | NR iteration limit |
| `tran_itl` | 50 | Transient NR iteration limit |
| `nr_conviter` | 1 | Required consecutive converged iterations |
| `nr_damping` | 0.8 | NR damping factor |
| `tran_fs` | 0.25 | Timestep safety factor |
| `tran_fmin` | 0.125 | Minimum step ratio |
| `tran_fmax` | 2.0 | Maximum step ratio |
| `tran_fbr` | 0.125 | Breakpoint proximity factor |

---

## Ring Benchmark Statistics

From actual ring oscillator simulation:
- **Total NR iterations**: 84,685
- **Accepted timepoints**: 24,769
- **Rejected timepoints**: 0
- **Bypass opportunities**: 445,824
- **Bypassed evaluations**: 445,824 (100% rate)
- **System size**: 47 unknowns, 220 Jacobian entries

The high bypass rate indicates efficient steady-state operation where device terminals don't change significantly between iterations.

---

## 6. VACASK Defaults vs JAX-SPICE Comparison

### Tolerance Defaults

| Parameter | VACASK | JAX-SPICE | Status |
|-----------|--------|-----------|--------|
| `abstol` | 1e-12 | 1e-12 | ✅ Aligned |
| `reltol` | 1e-3 | 1e-3 | ✅ Have it |
| `vntol` | 1e-6 | ❌ | **Missing** - voltage tolerance for convergence |
| `chgtol` | 1e-15 | ❌ | **Missing** - charge tolerance (1mV across 1pF) |
| `fluxtol` | 1e-14 | ❌ | **Missing** - flux tolerance (1µA across 10nH) |
| `tolscale` | 1.0 | ❌ | **Missing** - global tolerance scaling factor |

### Environment Defaults

| Parameter | VACASK | JAX-SPICE | Status |
|-----------|--------|-----------|--------|
| `temp` | 27°C (300.15K) | 300.15K | ✅ Have it |
| `tnom` | 27°C (300.15K) | ❌ | **Missing** - nominal temp for model params |
| `gmin` | 1e-12 | 1e-12 | ✅ Have it |
| `gshunt` | 0.0 | 0.0 | ✅ Have it |
| `scale` | 1.0 | ❌ | **Missing** - geometry scaling factor |
| `minr` | 0.0 | ❌ | **Missing** - minimum resistance |

### Newton-Raphson Defaults

| Parameter | VACASK | JAX-SPICE | Status |
|-----------|--------|-----------|--------|
| `op_itl` | 100 | 100 | ✅ Have it |
| `tran_itl` | 10 | 100 | ⚠️ Different (VACASK uses 10 for transient) |
| `nr_damping` | 1.0 | 1.0 | ✅ Have it |
| `nr_conviter` | 1 | ❌ | **Missing** - consecutive converged iterations required |
| `nr_residualcheck` | 1 | ✅ | Have it (implicit) |
| `nr_convtol` | 0.01 | ❌ | **Missing** - instance convergence tolerance factor |
| `nr_bypasstol` | 0.01 | ❌ | **Missing** - instance bypass tolerance factor |
| `nr_bypass` | 0 | ❌ | **Missing** - instance bypass enable |
| `nr_force` | 1e5 | ❌ | **Missing** - nodeset/IC forcing factor |

### Transient Analysis Defaults

| Parameter | VACASK | JAX-SPICE | Status |
|-----------|--------|-----------|--------|
| `tran_method` | "trap" | trap | ✅ Have it |
| `tran_maxord` | 2 | ❌ | **Missing** (trap is fixed order 2) |
| `tran_predictor` | 0 | ❌ | **Missing** - use predictor for initial guess |
| `tran_redofactor` | 2.5 | ❌ | **Missing** - LTE rejection threshold |
| `tran_lteratio` | 3.5 | ❌ | **Missing** - LTE overestimation safety factor |
| `tran_xmu` | 0.5 | ❌ | **Missing** - trap/euler mixing (0.5=pure trap) |
| `tran_ft` | 0.25 | ❌ | **Missing** - timestep reduction factor on NR fail |
| `tran_fs` | 0.25 | ❌ | **Missing** - initial timestep fraction |
| `tran_fbr` | 0.2501 | ❌ | **Missing** - breakpoint proximity factor |
| `tran_trapltefilter` | 1 | ❌ | **Missing** - trap ringing filter |

### Homotopy Defaults

| Parameter | VACASK | JAX-SPICE | Status |
|-----------|--------|-----------|--------|
| `homotopy_gminsteps` | 100 | 100 | ✅ Have it |
| `homotopy_gminfactor` | 10.0 | 10.0 | ✅ Have it |
| `homotopy_startgmin` | 1e-3 | 1e-3 | ✅ Have it |
| `homotopy_mingmin` | 1e-15 | 1e-13 | ⚠️ Slightly different |
| `homotopy_srcsteps` | 100 | 100 | ✅ Have it |

---

## 7. LTE-Based Timestep Control (Detailed)

From `coretran.cpp:1070-1223`, the LTE algorithm:

### Predictor-Corrector Framework

```cpp
// Use polynomial extrapolation to predict x_{k+1}
predictorCoeffs.setMethod(PolynomialExtrapolation, order);
predictorCoeffs.predict(predictedSolution);

// NR solver computes corrector (actual solution)
// LTE ≈ corrector - predictor, scaled by error coefficients

double factor = integCoeffs.errorCoeff() /
                (integCoeffs.errorCoeff() - predictorCoeffs.errorCoeff());
// factor is always < 1 because:
//   - integrator errorCoeff is positive
//   - predictor errorCoeff is negative
```

### LTE Computation Per Unknown

```cpp
for (int i = 1; i <= n; i++) {
    // Compute LTE estimate
    double lte;
    if (tran_trapltefilter && method == AdamsMoulton && order == 2) {
        // Use filtered solution for trap ringing suppression
        lte = factor * (filteredSolution[i] - predictedSolution[i]);
    } else {
        lte = factor * (solution[i] - predictedSolution[i]);
    }

    // Compute tolerance based on relref setting
    double tolref;
    switch (relreflte) {
        case relrefGlobal:      // Max over all unknowns & time
            tolref = globalMaxSolution[nature_index];
            break;
        case relrefLocal:       // Max over time, per unknown
            tolref = historicMaxSolution[i];
            break;
        case relrefPointLocal:  // Current value only
            tolref = solution[i];
            break;
    }
    double tol = max(|tolref * reltol|, abstol[i]);

    // Compute scaled LTE ratio
    double ratio;
    if (tran_spicelte) {
        // SPICE-compatible (incorrect) formulation
        ratio = |lte| / (tol * lteratio * factorial(order + 1));
    } else {
        // Correct formulation
        ratio = |lte| / (tol * lteratio);
    }

    maxRatio = max(maxRatio, ratio);
}
```

### Timestep Adjustment

```cpp
// If maxRatio > 0, compute new timestep
if (maxRatio > 0) {
    double hkFactor;
    if (tran_spicelte) {
        // SPICE: LTE ∝ h^order
        hkFactor = pow(maxRatio, -1.0 / order);
    } else {
        // Correct: LTE ∝ h^(order+1)
        hkFactor = pow(maxRatio, -1.0 / (order + 1));
    }
    hkNew = min(hkNew, hk * hkFactor);
}

// Check if timestep should be rejected
double hkRatio = hk / hkNew;
if (tran_redofactor > 0 && hkRatio > tran_redofactor) {
    // LTE too large, reject timepoint
    accept = false;
    // Will retry with smaller step
} else {
    accept = true;
    // Optionally increase order
    if (order < maxOrder) {
        order++;
    }
}
```

### Trap Ringing Filter

For trapezoidal integration, spurious oscillations can occur. VACASK uses a filter:

```cpp
// Need at least 3 past points for filter
if (trapHistory >= 3 && method == AdamsMoulton && order == 2) {
    for (int i = 1; i <= n; i++) {
        auto x0 = solution[i];      // Latest
        auto x1 = solution(1)[i];   // t_k
        auto x2 = solution(2)[i];   // t_{k-1}
        auto x3 = solution(3)[i];   // t_{k-2}

        // Compute envelope slopes
        auto k13 = (x1 - x3) / (hk1 + hk2);  // Odd points envelope
        auto k02 = (x0 - x2) / (hk1 + hk);   // Even points envelope

        // Estimate envelope width at x2
        auto deltaEnvelopeAt2 = x2 - (x3 + k13 * hk2);

        // Corrected solution removes half the envelope width
        filteredSolution[i] = x0 - deltaEnvelopeAt2 / 2;
    }
}
```

### Timestep Limiting Factors

The new timestep is limited by multiple factors:

```cpp
// 1. Maxstep parameter
if (params.maxstep > 0) {
    hmax = min(hmax, params.maxstep);
}

// 2. Simulation interval
if (tran_minpts > 0) {
    hmax = min(hmax, (params.stop - params.start) / tran_minpts);
}

// 3. Breakpoint proximity (avoid tiny steps near breakpoints)
hmax = min(hmax, tran_fbr * (nextBreakpoint - lastBreakpoint));

// 4. Device-requested bound_step ($bound_step in Verilog-A)
if (boundStep > 0) {
    hkNew = min(hkNew, boundStep);
}

// 5. Apply hmax
hkNew = min(hkNew, hmax);

// 6. Breakpoint cutting (land exactly on breakpoint)
if (tk + hkNew > nextBreakpoint) {
    hkNew = nextBreakpoint - tk;
    tSolveNew = nextBreakpoint;
}
```

---

## 8. openvaf-py Instance Core Data Exports

### Currently Exported

| Data | openvaf-py | JAX-SPICE Usage |
|------|------------|-----------------|
| `residuals_resist` | ✅ Array per node | Used for f(x) |
| `residuals_react` | ✅ Array per node | Used for Q(x) |
| `jacobian_resist` | ✅ Flattened array | Used for ∂f/∂V |
| `jacobian_react` | ✅ Flattened array | Used for ∂Q/∂V |
| `lim_rhs_resist` | ✅ Array per node | Limiting RHS correction |
| `lim_rhs_react` | ✅ Array per node | Limiting RHS correction |
| `node_names` | ✅ List | For result mapping |
| `jacobian_keys` | ✅ (row, col) pairs | For sparse stamping |
| `terminals` | ✅ List | External connections |
| `internal_nodes` | ✅ List | Internal nodes (e.g., NOI) |
| `collapsible_pairs` | ✅ List | Node collapse info |
| `collapse_decision_outputs` | ✅ List | Dynamic collapse decisions |

### Not Currently Exported (Needed for Full VACASK Parity)

| Data | VACASK Location | Purpose |
|------|-----------------|---------|
| `state_index_table` | `stateIndexTable()` | Maps states to global vector for multi-rate |
| `bound_step` | `bound_step_offset` | Device-requested max timestep ($bound_step) |
| `node_mapping_array` | `nodeMappingArray()` | Maps internal→system unknowns |
| `jacobian_pointers` | `resistiveJacobianPointers()` | Direct sparse matrix pointers |

### Priority for Implementation

1. **High**: `bound_step` - Needed for PSP103 and complex models that use $bound_step
2. **Medium**: `state_index_table` - Needed for multi-rate integration
3. **Low**: `jacobian_pointers`, `node_mapping_array` - Optimization for sparse stamping

---

## 9. Voltage Source Implementation Comparison

### JAX-SPICE: High-Conductance Stamp

```python
G_vsource = 1e12  # Very large conductance

# Jacobian contribution
J[p, p] += G
J[p, n] -= G
J[n, p] -= G
J[n, n] += G

# Residual contribution
f[p] += G * (V[p] - V[n] - Vsource)
f[n] -= G * (V[p] - V[n] - Vsource)
```

**Problem**: Creates ~1kA residual per 1nV error → dominates convergence check
**Solution**: Mask vsource nodes from residual convergence check

### VACASK: Branch Current MNA

From `devvisrc.cpp`:

```cpp
// Adds extra unknown: branch current I_branch
// nodes_[0] = positive terminal
// nodes_[1] = negative terminal
// nodes_[2] = branch current (extra unknown)

// Jacobian entries (not 1e12, just ±1 and ±mfactor)
jacPFlow += mfactor;   // dI(p)/dI_branch = +mfactor
jacNFlow -= mfactor;   // dI(n)/dI_branch = -mfactor
jacFlowP -= 1.0;       // d(Vp-Vn)/dVp = -1
jacFlowN += 1.0;       // d(Vp-Vn)/dVn = +1

// Residual (KCL at nodes + voltage equation)
residual[p] += mfactor * I_branch;
residual[n] -= mfactor * I_branch;
residual[flow] = V[p] - V[n] - Vsource;  // O(1) magnitude
```

**Advantage**: O(1) residuals → no masking needed, tight abstol works naturally
