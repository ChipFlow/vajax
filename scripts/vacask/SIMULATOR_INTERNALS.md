# VACASK Simulator Internals for Ring Benchmark

This document provides detailed information about VACASK's internal algorithms for comparison with other simulators.

## 1. Device Model Evaluation (OpenVAF Output, Cached Values)

### OSDI Descriptor Structure

OpenVAF compiles Verilog-A models to shared libraries that implement the OSDI 0.4 API. The `OsdiDescriptor` structure defines the interface:

```c
typedef struct OsdiDescriptor {
    // Device identification
    char *name;
    uint32_t num_nodes;
    uint32_t num_terminals;
    OsdiNode *nodes;

    // Jacobian structure (pre-computed sparsity pattern)
    uint32_t num_jacobian_entries;
    OsdiJacobianEntry *jacobian_entries;
    uint32_t num_resistive_jacobian_entries;
    uint32_t num_reactive_jacobian_entries;

    // Node collapsing info
    uint32_t num_collapsible;
    OsdiNodePair *collapsible;
    uint32_t collapsed_offset;

    // Parameter info
    uint32_t num_params;
    uint32_t num_instance_params;
    uint32_t num_opvars;
    OsdiParamOpvar *param_opvar;

    // Memory layout offsets
    uint32_t node_mapping_offset;
    uint32_t jacobian_ptr_resist_offset;
    uint32_t state_idx_off;
    uint32_t bound_step_offset;
    uint32_t instance_size;
    uint32_t model_size;

    // API functions (generated by OpenVAF)
    void *(*access)(void *inst, void *model, uint32_t id, uint32_t flags);
    void (*setup_model)(void *handle, void *model, OsdiSimParas *sim_params, OsdiInitInfo *res);
    void (*setup_instance)(void *handle, void *inst, void *model, double temperature,
                           uint32_t num_terminals, OsdiSimParas *sim_params, OsdiInitInfo *res);
    uint32_t (*eval)(void *handle, void *inst, void *model, OsdiSimInfo *info);
    void (*load_noise)(void *inst, void *model, double freq, double *noise_dens);
    void (*load_residual_resist)(void *inst, void *model, double *dst);
    void (*load_residual_react)(void *inst, void *model, double *dst);
    void (*load_limit_rhs_resist)(void *inst, void *model, double *dst);
    void (*load_limit_rhs_react)(void *inst, void *model, double *dst);
    void (*load_jacobian_resist)(void *inst, void *model);
    void (*load_jacobian_react)(void *inst, void *model, double alpha);
    void (*load_jacobian_tran)(void *inst, void *model, double alpha);
    // ... additional functions
} OsdiDescriptor;
```

### Cached Values in Instance Core

Each OSDI instance maintains a memory block (`core_`) containing:

| Offset | Data | Purpose |
|--------|------|---------|
| `node_mapping_offset` | Node mapping array | Maps internal nodes to system unknowns |
| `collapsed_offset` | Collapsed nodes pattern | Bitmap of collapsed internal nodes |
| `jacobian_ptr_resist_offset` | Jacobian pointers (resist) | Direct pointers to sparse matrix entries |
| `jacobian_ptr_react_offset` | Jacobian pointers (react) | Reactive Jacobian pointers |
| `state_idx_off` | State index table | Maps states to global state vector |
| `nodes[i].resist_residual_off` | Node residuals (resist) | I(V) contributions per node |
| `nodes[i].react_residual_off` | Node residuals (react) | Q(V) contributions per node |
| `nodes[i].resist_limit_rhs_off` | Limiting RHS (resist) | Linearized limiting correction |
| `nodes[i].react_limit_rhs_off` | Limiting RHS (react) | Reactive limiting correction |
| `(model-specific)` | Parameters & internal vars | Model and instance parameters |

### Evaluation Flow (evalCore)

The `eval()` function generated by OpenVAF performs:

1. **Read terminal voltages** from solution vector via node mapping
2. **Evaluate model equations** (branch currents, charges, noise)
3. **Compute Jacobian derivatives** (∂I/∂V, ∂Q/∂V)
4. **Apply limiting functions** if enabled (pnjlim, fetlim, etc.)
5. **Store results** in instance core memory

### Evaluation Flags

```c
#define CALC_RESIST_RESIDUAL     1    // Compute I(V)
#define CALC_REACT_RESIDUAL      2    // Compute Q(V)
#define CALC_RESIST_JACOBIAN     4    // Compute dI/dV
#define CALC_REACT_JACOBIAN      8    // Compute dQ/dV
#define CALC_NOISE              16    // Compute noise sources
#define CALC_OP                 32    // Operating point analysis
#define CALC_RESIST_LIM_RHS     64    // Compute limiting RHS (resist)
#define CALC_REACT_LIM_RHS     128    // Compute limiting RHS (react)
#define ENABLE_LIM             256    // Enable limiting
#define INIT_LIM               512    // Initialize limiting state
#define ANALYSIS_DC           2048    // DC analysis flag
#define ANALYSIS_TRAN         8192    // Transient analysis flag
```

### Return Flags

```c
#define EVAL_RET_FLAG_LIM     1   // Limiting was applied
#define EVAL_RET_FLAG_FATAL   2   // Fatal error, abort
#define EVAL_RET_FLAG_FINISH  4   // $finish called
#define EVAL_RET_FLAG_STOP    8   // $stop called
```

---

## 2. Charge Integration (dQ/dt Operator)

### General Formulation

Circuit equations in transient:
```
f(x(t)) + d/dt q(x(t)) = 0

where:
  x(t) = solution (unknowns)
  f(x) = resistive residual (currents)
  q(x) = reactive residual (charges)
```

### Integration Methods

VACASK supports two families of implicit integration methods:

#### Adams-Moulton (AM)

```
x_{k+1} = a_0 * x_k + h_k * (b_{-1} * x'_{k+1} + b_0 * x'_k + b_1 * x'_{k-1} + ...)

Order 1: Backward Euler
  a_0 = 1, b_{-1} = 1

Order 2: Trapezoidal (with xmu parameter)
  a_0 = 1
  b_{-1} = 1 - xmu  (default xmu=0.5 gives pure trapezoidal)
  b_0 = xmu

  Special cases:
    xmu = 0.5: Pure trapezoidal (b_{-1} = b_0 = 0.5)
    xmu = 0.0: Backward Euler (b_{-1} = 1, b_0 = 0)
```

#### BDF (Backward Differentiation Formula, aka Gear)

```
sum_{i=0}^{order-1} a_i * x_{k-i} = h_k * b_{-1} * x'_{k+1}

Order 1: Backward Euler (same as AM1)
  a_0 = 1, b_{-1} = 1

Order 2: Gear-2
  a_0 = 18/11, a_1 = -9/11, a_2 = 2/11
  b_{-1} = 6/11
```

### Differentiate Function

To compute ẋ(t_{k+1}) from x(t_{k+1}):

```cpp
double differentiate(double futureValue, GlobalStorageIndex state) {
    // leading_ = 1 / (h_k * b_{-1})
    double deriv = leading_ * futureValue;

    // Past values contribution
    for (int i = 0; i < aScaled_.size(); i++) {
        // aScaled_[i] = a_i / (h_k * b_{-1})
        deriv -= aScaled_[i] * history[i][state];
    }

    // Past derivatives contribution (AM methods only)
    for (int i = 0; i < bScaled_.size(); i++) {
        // bScaled_[i] = b_i / b_{-1}
        deriv -= bScaled_[i] * history[i][state + 1];  // state+1 holds derivative
    }

    return deriv;
}
```

### Transient Jacobian Contribution

The reactive contribution to the system Jacobian:

```
di/dx|_{k+1} = (1 / (h_k * b_{-1})) * dq/dx|_{k+1}
                 ↑                      ↑
              alpha                reactive Jacobian
```

This is loaded via:
```cpp
descriptor->load_jacobian_tran(instance, model, alpha);
// Adds: dI/dV + alpha * dQ/dV  where alpha = 1/(h_k * b_{-1})
```

### State Vector Layout

For each node with reactive residual:
```
states[2*i]   = q(t_k)      // Charge at current timepoint
states[2*i+1] = q'(t_k)     // dq/dt at current timepoint (computed current)
```

### Integration Coefficient Computation

Coefficients are recomputed at each timestep to handle variable step sizes:

```cpp
bool IntegratorCoeffs::compute(CircularBuffer<double>& pastSteps, double newStep) {
    // Normalize past timepoints by new step
    normalizedTimePoint[0] = 0.0;  // t_k
    for (int i = 0; i < pastSteps.valueCount(); i++) {
        normalizedTimePoint[i+1] = normalizedTimePoint[i] - pastSteps.at(i);
    }
    for (int i = 1; i < normalizedTimePoint.size(); i++) {
        normalizedTimePoint[i] /= newStep;
    }

    // Build and solve system of equations for coefficients
    // ...
}
```

---

## 3. Newton-Raphson Residual/Convergence Handling

### NR Algorithm Overview

```cpp
// Pseudocode for NR loop
run(continuePrevious) {
    initialize();
    if (!continuePrevious) {
        zero(solution);
    }
    do {
        zero(Jacobian, residual);
        preIteration();
        buildSystem();          // Evaluate devices, load Jacobian and residual
        loadForces();           // Apply nodesets/ICs
        [ok, limiting] = checkResidual();
        factor_and_solve();     // KLU sparse solver
        postSolve();
        checkDelta();           // Only if iteration > 1
        checkConvergence();
        if (converged) break;
        update_solution();
        rotate_solutions();
        postIteration();
    } while (iteration < itlim);
}
```

### NR Settings

```cpp
struct NRSettings {
    int debug {0};           // Debug verbosity level
    Int itlim {100};         // Iteration limit (first point)
    Int itlimCont {50};      // Iteration limit (continuation)
    Int convIter {1};        // Required consecutive converged iterations
    bool residualCheck {true};
    Real dampingFactor {0.8};
    bool matrixCheck {};
    bool rhsCheck {};
    bool solutionCheck {};
    Real forceFactor {1e5};  // Force scaling factor
};
```

### Convergence Criteria

#### Residual Check (checkResidual)

For each unknown i (excluding ground):

```cpp
// Compute tolerance reference
double tolref = |maxResidualContribution[i]|;

// Apply historic/global reference if configured
if (historicResRef) {
    if (globalResRef) {
        tolref = max(tolref, globalMaxResidualContribution[nature_index]);
    } else {
        tolref = max(tolref, historicMaxResidualContribution[i]);
    }
} else if (globalResRef) {
    tolref = max(tolref, pointMaxResidualContribution[nature_index]);
}

// Compute tolerance
double tol = max(|tolref * reltol|, abstol[i]);

// Check if residual is within tolerance
if (|residual[i]| > tol) {
    residualOk = false;
}
```

Where:
- `reltol` = relative tolerance (default 1e-3)
- `abstol[i]` = absolute tolerance based on nature (voltage: vntol, current: abstol)

#### Delta Check (checkDelta)

For each unknown i:

```cpp
// Compute tolerance reference (from previous solution)
double tolref = |x_prev[i]|;

// Apply historic/global reference if configured
if (historicSolRef) {
    if (globalSolRef) {
        tolref = max(tolref, globalMaxSolution[nature_index]);
    } else {
        tolref = max(tolref, historicMaxSolution[i]);
    }
} else if (globalSolRef) {
    tolref = max(tolref, pointMaxSolution[nature_index]);
}

// Compute tolerance
double tol = max(|tolref * reltol|, abstol[i]);

// Check if solution change is within tolerance
if (|delta[i]| > tol) {
    deltaOk = false;
}
```

### Convergence with Limiting

When limiting is applied, convergence is prevented:

```cpp
[ok, limitingApplied] = buildSystem();
// If limitingApplied is true, do not allow convergence this iteration
```

### SPICE Formulation with Limiting

```
Gl_i * (x_i - x_{i+1}) = f(xl_i) - Gl_i * (xl_i - x_i)
                         ↑         ↑
                      residual    RHS linearized residual
```

Where:
- `xl_i` = limited unknowns (after applying pnjlim, fetlim, etc.)
- `Gl_i` = Jacobian evaluated at limited point
- `f(xl_i)` = residual at limited point

---

## 4. Time-Stepping Algorithms

### Method Selection

```cpp
// Available methods (tran_method option)
"euler"  → AdamsMoulton order 1
"trap"   → AdamsMoulton order 2 (default xmu=0.5)
"am"     → AdamsMoulton order 1..tran_maxord
"bdf"    → BDF order 1..tran_maxord
"gear"   → BDF order 1..tran_maxord (alias)
"bdf2"   → BDF order 2 fixed
"gear2"  → BDF order 2 fixed (alias)
```

### Trapezoidal Algorithm (default)

Integration formula:
```
x_{k+1} = x_k + h_k * ((1-xmu) * x'_{k+1} + xmu * x'_k)

For xmu = 0.5 (pure trapezoidal):
x_{k+1} = x_k + (h_k/2) * (x'_{k+1} + x'_k)
```

Differentiate:
```
x'_{k+1} = (2/h_k) * (x_{k+1} - x_k) - x'_k
         = (2/h_k) * x_{k+1} - (2/h_k) * x_k - x'_k
```

Leading coefficient: `alpha = 2/h_k`

Error coefficient: `C = (1/24) * 3! = 1/4` (multiplied by (order+1)!)

### BDF-2 (Gear-2) Algorithm

Integration formula:
```
(18/11)*x_k - (9/11)*x_{k-1} + (2/11)*x_{k-2} = (6/11) * h_k * x'_{k+1}
```

Differentiate:
```
x'_{k+1} = (11/(6*h_k)) * ((18/11)*x_k - (9/11)*x_{k-1} + (2/11)*x_{k-2})
         = (3/h_k)*x_k - (3/(2*h_k))*x_{k-1} + (1/(3*h_k))*x_{k-2}
```

Leading coefficient: `alpha = 11/(6*h_k) ≈ 1.833/h_k`

Error coefficient: `C = (3/22) * 3! = 9/11`

### Timestep Control

Initial timestep `h0` is limited by:
1. User-specified `step` parameter
2. `maxstep` if specified
3. `tran_ffmax/(2*maxFreq)` if fast frequency limit is set
4. `tran_fbr * (nextBreakpoint - lastBreakpoint)` near breakpoints
5. `boundStep` from device evaluation
6. Scaled by `tran_fs` factor

### LTE (Local Truncation Error) Based Control

```cpp
// Predictor uses polynomial extrapolation
predictorCoeffs.setMethod(PolynomialExtrapolation, order);

// Predict x_{k+1} from history
predict(predictedSolution);

// After NR convergence, estimate LTE
for (int i = 1; i <= n; i++) {
    double lte = |solution[i] - predictedSolution[i]| / errorCoeff;
    scaledLte[i] = lte / tol[i];
}

// Compute optimal step
double maxScaledLte = max(scaledLte);
double q = pow(1.0 / maxScaledLte, 1.0 / (order + 1));
double hNew = q * hk;

// Clamp to reasonable range
hNew = clamp(hNew, hk * tran_fmin, hk * tran_fmax);
```

### Breakpoint Handling

Breakpoints occur at:
- PWL source transitions
- User-specified times
- `tstop` and `tstart`

```cpp
// Next solve time respects breakpoints
double nextBreakpoint = breakPoints.at(0);
if (tk + hk >= nextBreakpoint) {
    tSolve = nextBreakpoint;  // Land exactly on breakpoint
    hk = tSolve - tk;
}
```

### State Machine for Timestep Loop

```
1. Initial point at t=0 (via OP analysis or UIC)
2. Rotate states: current(0) → past(1)
3. Initialize: order=1, hk=h0

LOOP:
4. Compute coefficients for current order and step
5. Predict solution at t_{k+1}
6. Set up NR: solution[0] = predicted
7. Run NR solver at t_{k+1}
8. If NR failed:
   - Reduce timestep
   - If too small, abort
   - Retry from step 4
9. Check LTE
10. If LTE too large:
    - Reduce timestep
    - Retry from step 4
11. Accept point
12. Update maxima
13. Write output if t >= tstart
14. If t >= tstop: DONE
15. Compute next timestep
16. Rotate: current → past
17. Update order if history allows
18. GOTO LOOP
```

---

## 5. Numerical Robustness and Large Capacitance Handling

VACASK does not have explicit "large capacitance" detection or limiting. Instead, it relies on several general mechanisms that naturally handle extreme component values.

### Device-Level Timestep Bounding (`$bound_step`)

Verilog-A models can call `$bound_step(value)` to limit the simulator timestep. This is the primary mechanism for devices to communicate timestep constraints:

```cpp
// In EvalSetup (elsetup.h)
double boundStep {};  // Initialized to -1, set by devices

void setBoundStep(double bound) {
    if (bound < boundStep) boundStep = bound;
}

// Applied in coretran.cpp:1294
if (boundStep > 0) {
    if (debug > 1 && boundStep < hkNew) {
        Simulator::dbg() << "Instance(s) limit timestep to dt=" << boundStep << ".\n";
    }
    hkNew = std::min(hkNew, boundStep);
}
```

If a device model detects conditions requiring small timesteps (e.g., large dV/dt across a large capacitor), it can enforce this constraint.

### LTE-Based Automatic Timestep Reduction

Large capacitances naturally produce larger local truncation errors when voltages change rapidly:

```
LTE ∝ C * d²V/dt² * h^(order+1)
```

For trapezoidal integration (order 2):
- Large C with changing V → large LTE
- LTE/tolerance > 1 triggers timestep rejection
- New step: `h_new = h * (tolerance/LTE)^(1/3)`

This provides automatic protection without explicit capacitance checks.

### Matrix Conditioning and Numerical Checks

VACASK provides optional checks for numerical problems:

| Option | Default | Description |
|--------|---------|-------------|
| `matrixcheck` | 0 | Check Jacobian entries for inf/NaN |
| `rhscheck` | 1 | Check RHS vector for inf/NaN |
| `solutioncheck` | 1 | Check solution vector for inf/NaN |
| `rcondcheck` | 0 | Check reciprocal condition number (if > 0) |

#### Matrix Check

```cpp
// In NR solver iteration
if (settings.matrixCheck && !jacobian.isFinite(true, true)) {
    // Iteration fails, timestep will be reduced
    lastError = Error::MatrixError;
    return false;
}
```

#### Condition Number Check (AC/Noise analyses)

```cpp
// In coreac.cpp, corenoise.cpp, coreacxf.cpp
if (options.rcondcheck > 0) {
    double rcond;
    if (!acMatrix.rcond(rcond)) {
        setError(AcError::MatrixError);
        break;
    }
    if (rcond < options.rcondcheck) {
        Simulator::dbg() << "Matrix is close to singular.\n";
        setError(AcError::MatrixError);
        break;
    }
}
```

### Singular Matrix Detection

KLU (the sparse solver) detects zero pivots during factorization:

```cpp
// klumatrix.cpp:738
if (!numeric || isSingular || (nr >= 0 && nr != AN)) {
    lastError = Error::Factorization;
    errorIndex = singularColumn();
    // Error message: "Factorization failed, zero pivot @ node 'xxx'"
}
```

A large capacitance can contribute to singularity if:
- The `alpha = 1/(h*b_{-1})` term becomes very small (large timestep)
- Combined with small conductances elsewhere in the circuit

### Jacobian Contribution from Capacitance

During transient analysis, a capacitor C between nodes i and j contributes:

```
Jacobian[i,i] += alpha * C
Jacobian[i,j] -= alpha * C
Jacobian[j,i] -= alpha * C
Jacobian[j,j] += alpha * C

where alpha = 1/(h * b_{-1})
```

For trapezoidal: `alpha = 2/h`

**Potential issues with large C:**
- If `h` is large, `alpha*C` may be comparable to other conductances → OK
- If `h` is small (forced by LTE), `alpha*C` becomes very large → dominates matrix
- Very large `alpha*C` can cause conditioning issues if other elements are small

### What VACASK Does NOT Do

Unlike some SPICE variants, VACASK does not:
- Automatically insert `gmin` shunts across capacitors
- Warn about "unrealistic" capacitance values
- Scale or limit capacitance values
- Have special handling for floating capacitors

### Debugging Large Capacitance Issues

To diagnose problems with large capacitances:

```
control
  // Enable all numerical checks
  options matrixcheck=1
  options rhscheck=1
  options solutioncheck=1
  options rcondcheck=1e-15

  // Enable detailed debug output
  options tran_debug=2
  options nr_debug=1

  analysis tran step=1n stop=100n
endc
```

Signs of large capacitance problems:
1. **Very small timesteps** - LTE control forcing tiny steps
2. **"Matrix entry is not finite"** - overflow in Jacobian
3. **"Matrix is close to singular"** - conditioning issues
4. **"Factorization failed, zero pivot"** - numerical singularity
5. **Many NR iterations** - slow convergence due to stiff system

### Recommendations for Large Capacitances

1. **Use `maxstep`** to prevent excessively large timesteps:
   ```
   analysis tran step=1n stop=1u maxstep=10n
   ```

2. **Consider BDF-2** for stiff circuits (large C with small R):
   ```
   options tran_method="gear2"
   ```
   BDF-2 is A-stable and better suited for stiff systems.

3. **Enable matrix checks** during development:
   ```
   options matrixcheck=1 rcondcheck=1e-14
   ```

4. **Check device models** - ensure `$bound_step` is called appropriately for large reactive elements.

---

## Summary: Key Numerical Parameters

| Parameter | Default | Description |
|-----------|---------|-------------|
| `reltol` | 1e-3 | Relative tolerance |
| `vntol` | 1e-6 | Absolute voltage tolerance |
| `abstol` | 1e-12 | Absolute current tolerance |
| `tran_method` | "trap" | Integration method |
| `tran_maxord` | 2 | Maximum order |
| `tran_xmu` | 0.5 | Trapezoidal damping (0=Euler, 0.5=pure trap) |
| `nr_itl` | 100 | NR iteration limit |
| `tran_itl` | 50 | Transient NR iteration limit |
| `nr_conviter` | 1 | Required consecutive converged iterations |
| `nr_damping` | 0.8 | NR damping factor |
| `tran_fs` | 0.25 | Timestep safety factor |
| `tran_fmin` | 0.125 | Minimum step ratio |
| `tran_fmax` | 2.0 | Maximum step ratio |
| `tran_fbr` | 0.125 | Breakpoint proximity factor |

---

## Ring Benchmark Statistics

From actual ring oscillator simulation:
- **Total NR iterations**: 84,685
- **Accepted timepoints**: 24,769
- **Rejected timepoints**: 0
- **Bypass opportunities**: 445,824
- **Bypassed evaluations**: 445,824 (100% rate)
- **System size**: 47 unknowns, 220 Jacobian entries

The high bypass rate indicates efficient steady-state operation where device terminals don't change significantly between iterations.
